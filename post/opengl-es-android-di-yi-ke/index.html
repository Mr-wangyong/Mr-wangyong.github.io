<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>OpenGL es Android 第一课 | mrwang的编程之旅</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://mr-wangyong.github.io//favicon.ico?v=1666594550188">
<link rel="stylesheet" href="https://mr-wangyong.github.io//styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="
官网镇楼
OpenGL 简介

openGL 与 OpenGL ES 区别

OpenGL  跨平台的高性能3D渲染API


openGL ES（OpenGL for Embedded Systems）是 OpenGL 的子集，针对移动..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://mr-wangyong.github.io/">
        <img src="https://mr-wangyong.github.io//images/avatar.png?v=1666594550188" class="site-logo">
        <h1 class="site-title">mrwang的编程之旅</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/Mr-wangyong" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      好学若饥，谦卑若愚
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/Mr-wangyong" target="_blank">mrwang github</a> | <a class="rss" href="https://mr-wangyong.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">OpenGL es Android 第一课</h2>
            <div class="post-date">2021-06-01</div>
            
              <div class="feature-container" style="background-image: url('https://mr-wangyong.github.io//post-images/opengl-es-android-di-yi-ke.jpeg')">
              </div>
            
            <div class="post-content" v-pre>
              <blockquote>
<p>官网镇楼<br>
<a href="https://developer.android.com/guide/topics/graphics/opengl">OpenGL 简介</a></p>
</blockquote>
<h3 id="opengl-与-opengl-es-区别">openGL 与 OpenGL ES 区别</h3>
<blockquote>
<p>OpenGL  跨平台的高性能3D渲染API</p>
</blockquote>
<blockquote>
<p>openGL ES（OpenGL for Embedded Systems）是 OpenGL 的子集，针对移动设备及嵌入式设备设计的</p>
</blockquote>
<h3 id="opengl-版本">OpenGL 版本</h3>
<ol>
<li>1.0旧版本，API1 支持 基本废弃</li>
<li>2.0 Android 2.2 (API level 8)支持，相对于1.0版本改动很大，不兼容OpenGL ES 1.x，易用性得到提升，常用的都是这个版本，</li>
<li>3.0 Android 4.3 (API level 18) 支持，向下兼容OpenGL ES 2.x</li>
</ol>
<p>题外话：OpenGL2.0/3.0 中使用 openGL 都是static静态方法，比如</p>
<pre><code>GLES20.glClearColor(0f, 0f, 0f, 0f)
</code></pre>
<p>也可以是 GLES10/11/30/31/32 其中的数字就代表 openGL 的版本，看着设计，我只想说，碉堡了！！</p>
<hr>
<h2 id="基本概念">基本概念</h2>
<ol>
<li>Android 中OpenGL 承载为 GLSurfaceView，里面提供一个openGL 开发环境，上面说过openGL 方法调用都是static 静态的，但是只能在 Render 的 三个生命周期内调用</li>
</ol>
<pre><code>onSurfaceCreated
onSurfaceChanged
onDrawFrame
</code></pre>
<ol start="2">
<li>着色器(Shader)：是在GPU上运行的小程序。从名称可以看出，可通过处理它们来处理顶点。此程序使用<a href="https://de.wikipedia.org/wiki/OpenGL_ES_Shading_Language">openGL ES Shading language</a> 语言来编写。它是一个描述顶点或像素特性的简单程序，分为顶点着色器和片元着色器。</li>
<li>顶点着色器(vertex Shader)：指定几何形状的顶点，比如三角形的三个点</li>
<li>片元着色器(fragment shader):指定每个顶点之间的着色</li>
</ol>
<blockquote>
<p>顶点着色器和片元着色器是一一对应的，一个 GL 程序必须至少有一个vertex Shader 和 Fragment shader</p>
</blockquote>
<p>5.坐标轴，右手坐标系，跟 Android 的 Y 轴坐标刚好相反，这点要注意，后续的相关操作需要转换Y轴坐标<br>
6. 图形绘制：OpenGL只能绘制基本的点、线、三角形，其他图形都是由这三个基本元素组成的(大部分都是大量的三角形组成，所以衡量 GPU 性能常用单位时间绘制三角形数量表示)</p>
<h3 id="opengl-坐标">openGL 坐标</h3>
<ol>
<li>
<p>OpenGL坐标系<br>
<img src="https://mr-wangyong.github.io//post-images/1622542782569.png" alt="" loading="lazy"><br>
与Android中的Canvas或者屏幕坐标体系不同，GL的坐标起始位置在屏幕中心，(0,0)作为中心点，X坐标从左到右，Y坐标从下到上，在[-1,1]之间取值，再映射到屏幕上。而超出[-1,1]范围的，将不会显示在屏幕上。而无论屏幕是什么大小，什么形状，坐标范围都是不变的。如下图。</p>
</li>
<li>
<p>OpenGL ES纹理坐标<br>
以左下角为原点(Android是以左上角为原点的)<br>
<img src="https://mr-wangyong.github.io//post-images/1622543008883.png" alt="" loading="lazy"></p>
</li>
</ol>
<h3 id="gles语言">GLES语言</h3>
<p>顶点着色器的内建输入变量</p>
<p>gl_Position：顶点坐标<br>
gl_PointSize：点的大小，没有赋值则为默认值1</p>
<p>片元着色器内建输出变量<br>
gl_FragColor：当前片元颜色<br>
1）在顶点着色器中，传入了一个vec4的顶点坐标xyzw，然后直接传递给内建变量gl_Position，即直接根据顶点坐标渲染，不再做位置变换。</p>
<p>注：顶点坐标是在Java代码中传入的，后面会讲到，另外w是齐次坐标，2D渲染没有作用</p>
<p>2）在片元着色器中，直接给gl_FragColor赋值，依然是一个vec4类型的数据，这里表示rgba颜色值，为红色</p>
<p>这里讲的非常详细<br>
<a href="https://www.jianshu.com/p/355137fa2817">顶点坐标和纹理坐标</a></p>
<p>只有图片和视频才需要用到纹理坐标，其他的时候并没有什么用</p>
<hr>
<h2 id="实战开始-opengl-绘制之旅">实战，开始 OpenGL 绘制之旅</h2>
<ul>
<li>构建一个 GLSurfaceView</li>
</ul>
<pre><code>class GlActivity : AppCompatActivity() {

    private lateinit var glSurfaceView: GLSurfaceView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        glSurfaceView = GLSurfaceView(applicationContext)
        setContentView(glSurfaceView)

        // 设置 openGl 的类型 OpenGL ES 2.0
        glSurfaceView.setEGLContextClientVersion(2)
        // 设置 render
        glSurfaceView.setRenderer(getRender())
        // 设置渲染模式 一直渲染
        glSurfaceView.renderMode = GLSurfaceView.RENDERMODE_CONTINUOUSLY

    }

    private fun getRender(): GLSurfaceView.Renderer? {
        return PointsRender
    }

    override fun onResume() {
        super.onResume()
        glSurfaceView.onResume()
    }

    override fun onPause() {
        super.onPause()
        glSurfaceView.onPause()
    }



}
</code></pre>
<p>几个关键步骤：</p>
<ol>
<li>创建一个 GLSurfaceView, 然后GLSurfaceView中 openGL 的版本</li>
<li>设置 Render, 这步骤是最重要的，所有的 openGL 相关代码都在 Render 生命周期内调用</li>
<li>设置渲染模式，两种
<ol>
<li>GLSurfaceView主动刷新(continuously)，不停的回调Renderer的onDrawFrame</li>
<li>被动刷新（when dirty），就是当请求刷新时才调一次onDrawFrame,调用方法为<code>glSurfaceView.requestRender()</code></li>
</ol>
</li>
</ol>
<pre><code>glSurfaceView.renderMode = GLSurfaceView.RENDERMODE_CONTINUOUSLY
</code></pre>
<p>我们这里为了方便，采用主动刷新</p>
<h2 id="render-编写">Render 编写</h2>
<p>这里也是最主要的内容<br>
和 C 语言一样，分为 编写源码-&gt; 编译(compile)-&gt;链接(link)-&gt;运行/绘制(draw)</p>
<h5 id="1-编写-render-源码">1. 编写 <strong>Render</strong> 源码</h5>
<blockquote>
<p>基本上都是一个固定的步骤<br>
创建一个vertex shader 和 fragment Shader,用的是<a href="https://de.wikipedia.org/wiki/OpenGL_ES_Shading_Language">openGL ES Shading language</a>  shader 描述语言，和 C 语言十分相似，能够直接操作矩阵和向量，直接运行在GPU 之上</p>
</blockquote>
<pre><code>//指定 绘制中心点为0，0，0 最后一个在2D 环境下永远为1.0, pointSize 表示点的大小为20
 private const val VERTEX_SHADER =
            &quot;void main() {\n&quot; +
                    &quot;gl_Position = vec4(0, 0, 0.0, 1.0);\n&quot; +
                    &quot;gl_PointSize = 20.0;\n&quot; +
                    &quot;}\n&quot;


    //gl_FragColor是fragment shader的内置变量，用于指定当前顶点的颜色，
    // 四个分量（r, g, b, a）。这里是想指定为红色，不透明。
    private const val FRAGMENT_SHADER =
            &quot;void main() {\n&quot; +
                    &quot;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n&quot; +
                    &quot;}\n&quot;
</code></pre>
<blockquote>
<p>shader 语言永远都有一个 main() 方法，<code>vec4</code> 为<a href="https://baike.baidu.com/item/%E9%BD%90%E6%AC%A1%E5%9D%90%E6%A0%87">齐次坐标</a>，<code>vec4</code>和<code>gl_PointSize</code>都是<code>vertex shader</code>内置变量, 可以直接使用，FragmentShader同理</p>
</blockquote>
<h5 id="2-编译-shder">2. 编译 shder</h5>
<blockquote>
<p>这一步主要把 shader源码隐射到 openGL 对象上(vsh)</p>
</blockquote>
<pre><code>// 创建一个vertex shader程序 返回值是一个句柄/程序指针 JNI 知识
        val vsh = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER)
        // 设置 vertex shader 源码

        GLES20.glShaderSource(vsh, VERTEX_SHADER)
        // 编译 vertex shader
        GLES20.glCompileShader(vsh)
        
        val fsh = GLES20.glCreateShader(GLES20.GL_FRAGMENT_SHADER)
        GLES20.glShaderSource(fsh, FRAGMENT_SHADER)
        GLES20.glCompileShader(fsh)
</code></pre>
<h5 id="3-链接-shader">3. 链接 shader</h5>
<blockquote>
<p>这一步主要是把vertex shader 和Fragment shader融合到 programs，生成最后的渲染对象，代码也是固定的</p>
</blockquote>
<pre><code>// 创建shader program句柄
        programs = GLES20.glCreateProgram()
        GLES20.glAttachShader(programs, vsh)// 把vertex shader添加到program
        GLES20.glAttachShader(programs, fsh)// 把fragment shader添加到program
        GLES20.glLinkProgram(programs)
</code></pre>
<h5 id="4-检测是否成功">4. 检测是否成功</h5>
<p>这一步不是必须的，但是一般都会这么做，<br>
status 为0表示正常，最后是打印出 program 的信息</p>
<pre><code>        GLES20.glValidateProgram(programs)  
        val status = IntArray(1)
        // 获取验证的状态 0为正常
        GLES20.glGetProgramiv(programs, GLES20.GL_VALIDATE_STATUS, status, 0)

        Log.d(TAG, &quot;validate shader program: &quot; + GLES20.glGetProgramInfoLog(programs))
</code></pre>
<h2 id="绘制-shader">绘制 shader</h2>
<p>代码也基本上是固定的</p>
<ol>
<li>清除颜色缓冲区，清除上一帧的数据，防止脏数据</li>
</ol>
<pre><code>GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)
</code></pre>
<ol start="2">
<li>设置shader</li>
</ol>
<p>把之前的编译链接好的shader传入</p>
<pre><code>GLES20.glUseProgram(programs)
</code></pre>
<ol start="3">
<li>绘制 shader<br>
因为只绘制一个点，所以传入1</li>
</ol>
<pre><code>GLES20.glDrawArrays(GLES20.GL_POINTS, 0, 1)
</code></pre>
<hr>
<p>最后 贴一下总的代码</p>
<h4 id="shader">shader</h4>
<pre><code>object PointsRender : GLSurfaceView.Renderer {

    
    private const val VERTEX_SHADER =
            &quot;void main() {\n&quot; +
                    &quot;gl_Position = vec4(-0.5, 0.5, 0.0, 1.0);\n&quot; +
                    &quot;gl_PointSize = 20.0;\n&quot; +
                    &quot;}\n&quot;


    private const val FRAGMENT_SHADER =
            &quot;void main() {\n&quot; +
                    &quot;gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n&quot; +
                    &quot;}\n&quot;

    private var programs: Int = -1


    override fun onSurfaceCreated(gl: GL10?, config: EGLConfig?) {
        GLES20.glClearColor(0f, 0f, 0f, 0f)

        val vsh = GLES20.glCreateShader(GLES20.GL_VERTEX_SHADER)
    
        GLES20.glShaderSource(vsh, VERTEX_SHADER)
        // 编译 vertex shader
        GLES20.glCompileShader(vsh)

        // 创建一个fragment shader程序
        val fsh = GLES20.glCreateShader(GLES20.GL_FRAGMENT_SHADER)
        GLES20.glShaderSource(fsh, FRAGMENT_SHADER)
        GLES20.glCompileShader(fsh)

        // 创建shader program句柄
        programs = GLES20.glCreateProgram()
        GLES20.glAttachShader(programs, vsh)// 把vertex shader添加到program
        GLES20.glAttachShader(programs, fsh)// 把fragment shader添加到program
        GLES20.glLinkProgram(programs)// 做链接，
        GLES20.glValidateProgram(programs)  // 让OpenGL来验证一下我们的shader program，并获取验证的状态

        val status = IntArray(1)
        GLES20.glGetProgramiv(programs, GLES20.GL_VALIDATE_STATUS, status, 0)

        Log.d(TAG, &quot;validate shader program: &quot; + GLES20.glGetProgramInfoLog(programs))
    }


    
    override fun onSurfaceChanged(gl: GL10?, width: Int, height: Int) {
        GLES20.glViewport(0, 0, width, height) // 参数是left, top, width, height
    }


    override fun onDrawFrame(gl: GL10?) {
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT)// 清除颜色缓冲区
        GLES20.glUseProgram(programs)
        GLES20.glDrawArrays(GLES20.GL_POINTS, 0, 1)// 开始渲染，发送渲染点的指令
    }


}
</code></pre>
<h4 id="glsurfaceview">GLSurfaceView</h4>
<pre><code>class GlActivity : AppCompatActivity() {

    private lateinit var glSurfaceView: GLSurfaceView

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        glSurfaceView = GLSurfaceView(applicationContext)
        setContentView(glSurfaceView)

        // 设置 openGl 的类型 OpenGL ES 2.0
        glSurfaceView.setEGLContextClientVersion(2)
        // 设置 render
        glSurfaceView.setRenderer(getRender())
        // 设置渲染模式 一直渲染
        glSurfaceView.renderMode = GLSurfaceView.RENDERMODE_CONTINUOUSLY
    }

    private fun getRender(): GLSurfaceView.Renderer? {
        return PointsRender
    }

    override fun onResume() {
        super.onResume()
        glSurfaceView.onResume()
    }

    override fun onPause() {
        super.onPause()
        glSurfaceView.onPause()
    }



}
</code></pre>
<hr>
<p>参考：</p>
<blockquote>
<p><a href="http://toughcoder.net/blog/2018/07/31/introduction-to-opengl-es-2-dot-0/">稀有猿诉 年轻人的第一篇OpenGL ES 2.0教程</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/junzia/article/list/3">湖广午王 openGL  教程</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.piasy.com/tags/#OpenGL">Piasy OpenGL 系列教程</a></p>
</blockquote>
<blockquote>
<p><a href="http://wiki.jikexueyuan.com/project/opengl-es-guide/api.html">极客学院OpenGL教程</a></p>
</blockquote>
<pre><code>mGLSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
</code></pre>
<p>选择自定义 EGLConfigChooser。<br>
指定 red ,green, blue, alpha, depth ,stencil 支持的位数，缺省为 RGB_565 ,16 bit depth buffer。</p>
<pre><code>setEGLConfigChooser (boolean)
</code></pre>
<p>选择一个 Config 接近 16bitRGB<br>
颜色模式，可以打开或关闭深度(Depth)Buffer ,缺省为RGB_565 并打开至少有 16bit 的 depth Buffer。</p>

            </div>
            
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
